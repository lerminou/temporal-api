<?php
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: temporal/api/workflowservice/v1/service.proto

namespace Temporal\Api\Workflowservice\V1;

/**
 * WorkflowService API is exposed to provide support for long running applications.  Application is expected to call
 *  StartWorkflowExecution to create an instance for each instance of long running workflow.  Such applications are expected
 *  to have a worker which regularly polls for WorkflowTask and ActivityTask from the WorkflowService.  For each
 *  WorkflowTask, application is expected to process the history of events for that session and respond back with next
 *  commands.  For each ActivityTask, application is expected to execute the actual logic for that task and respond back
 *  with completion or failure.  Worker is expected to regularly heartbeat while activity task is running.
 */
interface WorkflowServiceService extends \Lv\Grpc\Service
{
    /**
     * RegisterNamespace creates a new namespace which can be used as a container for all resources.  Namespace is a top level
     *  entity within Temporal, used as a container for all resources like workflow executions, task queues, etc.  Namespace
     *  acts as a sandbox and provides isolation for all resources within the namespace.  All resources belongs to exactly one
     *  namespace.
     */
    function RegisterNamespace(\Temporal\Api\Workflowservice\V1\RegisterNamespaceRequest $request) : \Temporal\Api\Workflowservice\V1\RegisterNamespaceResponse;
    /**
     * DescribeNamespace returns the information and configuration for a registered namespace.
     */
    function DescribeNamespace(\Temporal\Api\Workflowservice\V1\DescribeNamespaceRequest $request) : \Temporal\Api\Workflowservice\V1\DescribeNamespaceResponse;
    /**
     * ListNamespaces returns the information and configuration for all namespaces.
     */
    function ListNamespaces(\Temporal\Api\Workflowservice\V1\ListNamespacesRequest $request) : \Temporal\Api\Workflowservice\V1\ListNamespacesResponse;
    /**
     * (-- api-linter: core::0134::method-signature=disabled
     *      aip.dev/not-precedent: UpdateNamespace RPC doesn't follow Google API format. --)
     *  (-- api-linter: core::0134::response-message-name=disabled
     *      aip.dev/not-precedent: UpdateNamespace RPC doesn't follow Google API format. --)
     *  UpdateNamespace is used to update the information and configuration for a registered namespace.
     */
    function UpdateNamespace(\Temporal\Api\Workflowservice\V1\UpdateNamespaceRequest $request) : \Temporal\Api\Workflowservice\V1\UpdateNamespaceResponse;
    /**
     * DeprecateNamespace is used to update state of a registered namespace to DEPRECATED.  Once the namespace is deprecated
     *  it cannot be used to start new workflow executions.  Existing workflow executions will continue to run on
     *  deprecated namespaces.
     */
    function DeprecateNamespace(\Temporal\Api\Workflowservice\V1\DeprecateNamespaceRequest $request) : \Temporal\Api\Workflowservice\V1\DeprecateNamespaceResponse;
    /**
     * StartWorkflowExecution starts a new long running workflow instance.  It will create the instance with
     *  'WorkflowExecutionStarted' event in history and also schedule the first WorkflowTask for the worker to make the
     *  first command for this instance.  It will return 'WorkflowExecutionAlreadyStartedFailure', if an instance already
     *  exists with same workflowId.
     */
    function StartWorkflowExecution(\Temporal\Api\Workflowservice\V1\StartWorkflowExecutionRequest $request) : \Temporal\Api\Workflowservice\V1\StartWorkflowExecutionResponse;
    /**
     * GetWorkflowExecutionHistory returns the history of specified workflow execution.  It fails with 'NotFoundFailure' if specified workflow
     *  execution in unknown to the service.
     */
    function GetWorkflowExecutionHistory(\Temporal\Api\Workflowservice\V1\GetWorkflowExecutionHistoryRequest $request) : \Temporal\Api\Workflowservice\V1\GetWorkflowExecutionHistoryResponse;
    /**
     * PollWorkflowTaskQueue is called by application worker to process WorkflowTask from a specific task queue.  A
     *  WorkflowTask is dispatched to callers for active workflow executions, with pending workflow tasks.
     *  Application is then expected to call 'RespondWorkflowTaskCompleted' API when it is done processing the WorkflowTask.
     *  It will also create a 'WorkflowTaskStarted' event in the history for that session before handing off WorkflowTask to
     *  application worker.
     */
    function PollWorkflowTaskQueue(\Temporal\Api\Workflowservice\V1\PollWorkflowTaskQueueRequest $request) : \Temporal\Api\Workflowservice\V1\PollWorkflowTaskQueueResponse;
    /**
     * RespondWorkflowTaskCompleted is called by application worker to complete a WorkflowTask handed as a result of
     *  'PollWorkflowTaskQueue' API call.  Completing a WorkflowTask will result in new events for the workflow execution and
     *  potentially new ActivityTask being created for corresponding commands.  It will also create a WorkflowTaskCompleted
     *  event in the history for that session.  Use the 'taskToken' provided as response of PollWorkflowTaskQueue API call
     *  for completing the WorkflowTask.
     *  The response could contain a new workflow task if there is one or if the request asking for one.
     */
    function RespondWorkflowTaskCompleted(\Temporal\Api\Workflowservice\V1\RespondWorkflowTaskCompletedRequest $request) : \Temporal\Api\Workflowservice\V1\RespondWorkflowTaskCompletedResponse;
    /**
     * RespondWorkflowTaskFailed is called by application worker to indicate failure.  This results in
     *  WorkflowTaskFailedEvent written to the history and a new WorkflowTask created.  This API can be used by client to
     *  either clear sticky task queue or report any panics during WorkflowTask processing.  Temporal will only append first
     *  WorkflowTaskFailed event to the history of workflow execution for consecutive failures.
     */
    function RespondWorkflowTaskFailed(\Temporal\Api\Workflowservice\V1\RespondWorkflowTaskFailedRequest $request) : \Temporal\Api\Workflowservice\V1\RespondWorkflowTaskFailedResponse;
    /**
     * PollActivityTaskQueue is called by application worker to process ActivityTask from a specific task queue.  ActivityTask
     *  is dispatched to callers whenever a ScheduleTask command is made for a workflow execution.
     *  Application is expected to call 'RespondActivityTaskCompleted' or 'RespondActivityTaskFailed' once it is done
     *  processing the task.
     *  Application also needs to call 'RecordActivityTaskHeartbeat' API within 'heartbeatTimeoutSeconds' interval to
     *  prevent the task from getting timed out.  An event 'ActivityTaskStarted' event is also written to workflow execution
     *  history before the ActivityTask is dispatched to application worker.
     */
    function PollActivityTaskQueue(\Temporal\Api\Workflowservice\V1\PollActivityTaskQueueRequest $request) : \Temporal\Api\Workflowservice\V1\PollActivityTaskQueueResponse;
    /**
     * RecordActivityTaskHeartbeat is called by application worker while it is processing an ActivityTask.  If worker fails
     *  to heartbeat within 'heartbeatTimeoutSeconds' interval for the ActivityTask, then it will be marked as timedout and
     *  'ActivityTaskTimedOut' event will be written to the workflow history.  Calling 'RecordActivityTaskHeartbeat' will
     *  fail with 'NotFoundFailure' in such situations.  Use the 'taskToken' provided as response of
     *  PollActivityTaskQueue API call for heart beating.
     */
    function RecordActivityTaskHeartbeat(\Temporal\Api\Workflowservice\V1\RecordActivityTaskHeartbeatRequest $request) : \Temporal\Api\Workflowservice\V1\RecordActivityTaskHeartbeatResponse;
    /**
     * (-- api-linter: core::0136::prepositions=disabled
     *      aip.dev/not-precedent: "By" is used to indicate request type. --)
     *  RecordActivityTaskHeartbeatById is called by application worker while it is processing an ActivityTask.  If worker fails
     *  to heartbeat within 'heartbeatTimeoutSeconds' interval for the ActivityTask, then it will be marked as timed out and
     *  'ActivityTaskTimedOut' event will be written to the workflow history.  Calling 'RecordActivityTaskHeartbeatById' will
     *  fail with 'NotFoundFailure' in such situations.  Instead of using 'taskToken' like in RecordActivityTaskHeartbeat,
     *  use Namespace, WorkflowId and ActivityId
     */
    function RecordActivityTaskHeartbeatById(\Temporal\Api\Workflowservice\V1\RecordActivityTaskHeartbeatByIdRequest $request) : \Temporal\Api\Workflowservice\V1\RecordActivityTaskHeartbeatByIdResponse;
    /**
     * RespondActivityTaskCompleted is called by application worker when it is done processing an ActivityTask.  It will
     *  result in a new 'ActivityTaskCompleted' event being written to the workflow history and a new WorkflowTask
     *  created for the workflow so new commands could be made.  Use the 'taskToken' provided as response of
     *  PollActivityTaskQueue API call for completion. It fails with 'NotFoundFailure' if the taskToken is not valid
     *  anymore due to activity timeout.
     */
    function RespondActivityTaskCompleted(\Temporal\Api\Workflowservice\V1\RespondActivityTaskCompletedRequest $request) : \Temporal\Api\Workflowservice\V1\RespondActivityTaskCompletedResponse;
    /**
     * (-- api-linter: core::0136::prepositions=disabled
     *      aip.dev/not-precedent: "By" is used to indicate request type. --)
     *  RespondActivityTaskCompletedById is called by application worker when it is done processing an ActivityTask.
     *  It will result in a new 'ActivityTaskCompleted' event being written to the workflow history and a new WorkflowTask
     *  created for the workflow so new commands could be made.  Similar to RespondActivityTaskCompleted but use Namespace,
     *  WorkflowId and ActivityId instead of 'taskToken' for completion. It fails with 'NotFoundFailure'
     *  if the these Ids are not valid anymore due to activity timeout.
     */
    function RespondActivityTaskCompletedById(\Temporal\Api\Workflowservice\V1\RespondActivityTaskCompletedByIdRequest $request) : \Temporal\Api\Workflowservice\V1\RespondActivityTaskCompletedByIdResponse;
    /**
     * RespondActivityTaskFailed is called by application worker when it is done processing an ActivityTask.  It will
     *  result in a new 'ActivityTaskFailed' event being written to the workflow history and a new WorkflowTask
     *  created for the workflow instance so new commands could be made.  Use the 'taskToken' provided as response of
     *  PollActivityTaskQueue API call for completion. It fails with 'NotFoundFailure' if the taskToken is not valid
     *  anymore due to activity timeout.
     */
    function RespondActivityTaskFailed(\Temporal\Api\Workflowservice\V1\RespondActivityTaskFailedRequest $request) : \Temporal\Api\Workflowservice\V1\RespondActivityTaskFailedResponse;
    /**
     * (-- api-linter: core::0136::prepositions=disabled
     *      aip.dev/not-precedent: "By" is used to indicate request type. --)
     *  RespondActivityTaskFailedById is called by application worker when it is done processing an ActivityTask.
     *  It will result in a new 'ActivityTaskFailed' event being written to the workflow history and a new WorkflowTask
     *  created for the workflow instance so new commands could be made.  Similar to RespondActivityTaskFailed but use
     *  Namespace, WorkflowId and ActivityId instead of 'taskToken' for completion. It fails with 'NotFoundFailure'
     *  if the these Ids are not valid anymore due to activity timeout.
     */
    function RespondActivityTaskFailedById(\Temporal\Api\Workflowservice\V1\RespondActivityTaskFailedByIdRequest $request) : \Temporal\Api\Workflowservice\V1\RespondActivityTaskFailedByIdResponse;
    /**
     * RespondActivityTaskCanceled is called by application worker when it is successfully canceled an ActivityTask.  It will
     *  result in a new 'ActivityTaskCanceled' event being written to the workflow history and a new WorkflowTask
     *  created for the workflow instance so new commands could be made.  Use the 'taskToken' provided as response of
     *  PollActivityTaskQueue API call for completion. It fails with 'NotFoundFailure' if the taskToken is not valid
     *  anymore due to activity timeout.
     */
    function RespondActivityTaskCanceled(\Temporal\Api\Workflowservice\V1\RespondActivityTaskCanceledRequest $request) : \Temporal\Api\Workflowservice\V1\RespondActivityTaskCanceledResponse;
    /**
     * (-- api-linter: core::0136::prepositions=disabled
     *      aip.dev/not-precedent: "By" is used to indicate request type. --)
     *  RespondActivityTaskCanceledById is called by application worker when it is successfully canceled an ActivityTask.
     *  It will result in a new 'ActivityTaskCanceled' event being written to the workflow history and a new WorkflowTask
     *  created for the workflow instance so new commands could be made.  Similar to RespondActivityTaskCanceled but use
     *  Namespace, WorkflowId and ActivityId instead of 'taskToken' for completion. It fails with 'NotFoundFailure'
     *  if the these Ids are not valid anymore due to activity timeout.
     */
    function RespondActivityTaskCanceledById(\Temporal\Api\Workflowservice\V1\RespondActivityTaskCanceledByIdRequest $request) : \Temporal\Api\Workflowservice\V1\RespondActivityTaskCanceledByIdResponse;
    /**
     * RequestCancelWorkflowExecution is called by application worker when it wants to request cancellation of a workflow instance.
     *  It will result in a new 'WorkflowExecutionCancelRequested' event being written to the workflow history and a new WorkflowTask
     *  created for the workflow instance so new commands could be made. It fails with 'NotFoundFailure' if the workflow is not valid
     *  anymore due to completion or doesn't exist.
     */
    function RequestCancelWorkflowExecution(\Temporal\Api\Workflowservice\V1\RequestCancelWorkflowExecutionRequest $request) : \Temporal\Api\Workflowservice\V1\RequestCancelWorkflowExecutionResponse;
    /**
     * SignalWorkflowExecution is used to send a signal event to running workflow execution.  This results in
     *  WorkflowExecutionSignaled event recorded in the history and a workflow task being created for the execution.
     */
    function SignalWorkflowExecution(\Temporal\Api\Workflowservice\V1\SignalWorkflowExecutionRequest $request) : \Temporal\Api\Workflowservice\V1\SignalWorkflowExecutionResponse;
    /**
     * (-- api-linter: core::0136::prepositions=disabled
     *      aip.dev/not-precedent: "With" is used to indicate combined operation. --)
     *  SignalWithStartWorkflowExecution is used to ensure sending signal to a workflow.
     *  If the workflow is running, this results in WorkflowExecutionSignaled event being recorded in the history
     *  and a workflow task being created for the execution.
     *  If the workflow is not running or not found, this results in WorkflowExecutionStarted and WorkflowExecutionSignaled
     *  events being recorded in history, and a workflow task being created for the execution
     */
    function SignalWithStartWorkflowExecution(\Temporal\Api\Workflowservice\V1\SignalWithStartWorkflowExecutionRequest $request) : \Temporal\Api\Workflowservice\V1\SignalWithStartWorkflowExecutionResponse;
    /**
     * ResetWorkflowExecution reset an existing workflow execution to WorkflowTaskCompleted event(exclusive).
     *  And it will immediately terminating the current execution instance.
     */
    function ResetWorkflowExecution(\Temporal\Api\Workflowservice\V1\ResetWorkflowExecutionRequest $request) : \Temporal\Api\Workflowservice\V1\ResetWorkflowExecutionResponse;
    /**
     * TerminateWorkflowExecution terminates an existing workflow execution by recording WorkflowExecutionTerminated event
     *  in the history and immediately terminating the execution instance.
     */
    function TerminateWorkflowExecution(\Temporal\Api\Workflowservice\V1\TerminateWorkflowExecutionRequest $request) : \Temporal\Api\Workflowservice\V1\TerminateWorkflowExecutionResponse;
    /**
     * ListOpenWorkflowExecutions is a visibility API to list the open executions in a specific namespace.
     */
    function ListOpenWorkflowExecutions(\Temporal\Api\Workflowservice\V1\ListOpenWorkflowExecutionsRequest $request) : \Temporal\Api\Workflowservice\V1\ListOpenWorkflowExecutionsResponse;
    /**
     * ListClosedWorkflowExecutions is a visibility API to list the closed executions in a specific namespace.
     */
    function ListClosedWorkflowExecutions(\Temporal\Api\Workflowservice\V1\ListClosedWorkflowExecutionsRequest $request) : \Temporal\Api\Workflowservice\V1\ListClosedWorkflowExecutionsResponse;
    /**
     * ListWorkflowExecutions is a visibility API to list workflow executions in a specific namespace.
     */
    function ListWorkflowExecutions(\Temporal\Api\Workflowservice\V1\ListWorkflowExecutionsRequest $request) : \Temporal\Api\Workflowservice\V1\ListWorkflowExecutionsResponse;
    /**
     * ListArchivedWorkflowExecutions is a visibility API to list archived workflow executions in a specific namespace.
     */
    function ListArchivedWorkflowExecutions(\Temporal\Api\Workflowservice\V1\ListArchivedWorkflowExecutionsRequest $request) : \Temporal\Api\Workflowservice\V1\ListArchivedWorkflowExecutionsResponse;
    /**
     * ScanWorkflowExecutions is a visibility API to list large amount of workflow executions in a specific namespace without order.
     */
    function ScanWorkflowExecutions(\Temporal\Api\Workflowservice\V1\ScanWorkflowExecutionsRequest $request) : \Temporal\Api\Workflowservice\V1\ScanWorkflowExecutionsResponse;
    /**
     * CountWorkflowExecutions is a visibility API to count of workflow executions in a specific namespace.
     */
    function CountWorkflowExecutions(\Temporal\Api\Workflowservice\V1\CountWorkflowExecutionsRequest $request) : \Temporal\Api\Workflowservice\V1\CountWorkflowExecutionsResponse;
    /**
     * GetSearchAttributes is a visibility API to get all legal keys that could be used in list APIs
     */
    function GetSearchAttributes(\Temporal\Api\Workflowservice\V1\GetSearchAttributesRequest $request) : \Temporal\Api\Workflowservice\V1\GetSearchAttributesResponse;
    /**
     * RespondQueryTaskCompleted is called by application worker to complete a QueryTask (which is a WorkflowTask for query)
     *  as a result of 'PollWorkflowTaskQueue' API call. Completing a QueryTask will unblock the client call to 'QueryWorkflow'
     *  API and return the query result to client as a response to 'QueryWorkflow' API call.
     */
    function RespondQueryTaskCompleted(\Temporal\Api\Workflowservice\V1\RespondQueryTaskCompletedRequest $request) : \Temporal\Api\Workflowservice\V1\RespondQueryTaskCompletedResponse;
    /**
     * ResetStickyTaskQueue resets the sticky task queue related information in mutable state of a given workflow.
     *  Things cleared are:
     *  1. StickyTaskQueue
     *  2. StickyScheduleToStartTimeout
     */
    function ResetStickyTaskQueue(\Temporal\Api\Workflowservice\V1\ResetStickyTaskQueueRequest $request) : \Temporal\Api\Workflowservice\V1\ResetStickyTaskQueueResponse;
    /**
     * QueryWorkflow returns query result for a specified workflow execution
     */
    function QueryWorkflow(\Temporal\Api\Workflowservice\V1\QueryWorkflowRequest $request) : \Temporal\Api\Workflowservice\V1\QueryWorkflowResponse;
    /**
     * DescribeWorkflowExecution returns information about the specified workflow execution.
     */
    function DescribeWorkflowExecution(\Temporal\Api\Workflowservice\V1\DescribeWorkflowExecutionRequest $request) : \Temporal\Api\Workflowservice\V1\DescribeWorkflowExecutionResponse;
    /**
     * DescribeTaskQueue returns information about the target task queue, right now this API returns the
     *  pollers which polled this task queue in last few minutes.
     */
    function DescribeTaskQueue(\Temporal\Api\Workflowservice\V1\DescribeTaskQueueRequest $request) : \Temporal\Api\Workflowservice\V1\DescribeTaskQueueResponse;
    /**
     * GetClusterInfo returns information about temporal cluster
     */
    function GetClusterInfo(\Temporal\Api\Workflowservice\V1\GetClusterInfoRequest $request) : \Temporal\Api\Workflowservice\V1\GetClusterInfoResponse;
    function ListTaskQueuePartitions(\Temporal\Api\Workflowservice\V1\ListTaskQueuePartitionsRequest $request) : \Temporal\Api\Workflowservice\V1\ListTaskQueuePartitionsResponse;
}
