<?php
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# source: temporal/api/schedule/v1/message.proto

namespace Temporal\Api\Schedule\V1;

use Google\Protobuf\Internal\GPBType;
use Google\Protobuf\Internal\RepeatedField;
use Google\Protobuf\Internal\GPBUtil;

/**
 * ScheduleSpec is a complete description of a set of absolute timestamps
 * (possibly infinite) that an action should occur at. The meaning of a
 * ScheduleSpec depends only on its contents and never changes, except that the
 * definition of a time zone can change over time (most commonly, when daylight
 * saving time policy changes for an area). To create a totally self-contained
 * ScheduleSpec, use UTC or include timezone_data.
 *
 * Generated from protobuf message <code>temporal.api.schedule.v1.ScheduleSpec</code>
 */
class ScheduleSpec extends \Google\Protobuf\Internal\Message
{
    /**
     * Calendar-based specifications of times.
     *
     * Generated from protobuf field <code>repeated .temporal.api.schedule.v1.CalendarSpec calendar = 1;</code>
     */
    private $calendar;
    /**
     * Interval-based specifications of times.
     *
     * Generated from protobuf field <code>repeated .temporal.api.schedule.v1.IntervalSpec interval = 2;</code>
     */
    private $interval;
    /**
     * Any timestamps matching any of the exclude_calendar specs will be
     * skipped.
     *
     * Generated from protobuf field <code>repeated .temporal.api.schedule.v1.CalendarSpec exclude_calendar = 3;</code>
     */
    private $exclude_calendar;
    /**
     * Any timestamps before start_time will be skipped. Together, start_time
     * and end_time make an inclusive interval.
     *
     * Generated from protobuf field <code>.google.protobuf.Timestamp start_time = 4 [(.gogoproto.stdtime) = true];</code>
     */
    protected $start_time = null;
    /**
     * Any timestamps after end_time will be skipped.
     *
     * Generated from protobuf field <code>.google.protobuf.Timestamp end_time = 5 [(.gogoproto.stdtime) = true];</code>
     */
    protected $end_time = null;
    /**
     * All timestamps will be incremented by a random value from 0 to this
     * amount of jitter. Default: 1 second
     *
     * Generated from protobuf field <code>.google.protobuf.Duration jitter = 6 [(.gogoproto.stdduration) = true];</code>
     */
    protected $jitter = null;
    /**
     * Time zone to interpret all CalendarSpecs in.
     * If unset, defaults to UTC. We recommend using UTC for your application if
     * at all possible, to avoid various surprising properties of time zones.
     * Time zones may be provided by name, corresponding to names in the IANA
     * time zone database (see https://www.iana.org/time-zones). The definition
     * will be loaded by the Temporal server from the environment it runs in.
     * If your application requires more control over the time zone definition
     * used, it may pass in a complete definition in the form of a TZif file
     * from the time zone database. If present, this will be used instead of
     * loading anything from the environment. You are then responsible for
     * updating timezone_data when the definition changes.
     * Calendar spec matching is based on literal matching of the clock time
     * with no special handling of DST: if you write a calendar spec that fires
     * at 2:30am and specify a time zone that follows DST, that action will not
     * be triggered on the day that has no 2:30am. Similarly, an action that
     * fires at 1:30am will be triggered twice on the day that has two 1:30s.
     *
     * Generated from protobuf field <code>string timezone_name = 10;</code>
     */
    protected $timezone_name = '';
    /**
     * Generated from protobuf field <code>bytes timezone_data = 11;</code>
     */
    protected $timezone_data = '';

    /**
     * Constructor.
     *
     * @param array $data {
     *     Optional. Data for populating the Message object.
     *
     *     @type \Temporal\Api\Schedule\V1\CalendarSpec[]|\Google\Protobuf\Internal\RepeatedField $calendar
     *           Calendar-based specifications of times.
     *     @type \Temporal\Api\Schedule\V1\IntervalSpec[]|\Google\Protobuf\Internal\RepeatedField $interval
     *           Interval-based specifications of times.
     *     @type \Temporal\Api\Schedule\V1\CalendarSpec[]|\Google\Protobuf\Internal\RepeatedField $exclude_calendar
     *           Any timestamps matching any of the exclude_calendar specs will be
     *           skipped.
     *     @type \Google\Protobuf\Timestamp $start_time
     *           Any timestamps before start_time will be skipped. Together, start_time
     *           and end_time make an inclusive interval.
     *     @type \Google\Protobuf\Timestamp $end_time
     *           Any timestamps after end_time will be skipped.
     *     @type \Google\Protobuf\Duration $jitter
     *           All timestamps will be incremented by a random value from 0 to this
     *           amount of jitter. Default: 1 second
     *     @type string $timezone_name
     *           Time zone to interpret all CalendarSpecs in.
     *           If unset, defaults to UTC. We recommend using UTC for your application if
     *           at all possible, to avoid various surprising properties of time zones.
     *           Time zones may be provided by name, corresponding to names in the IANA
     *           time zone database (see https://www.iana.org/time-zones). The definition
     *           will be loaded by the Temporal server from the environment it runs in.
     *           If your application requires more control over the time zone definition
     *           used, it may pass in a complete definition in the form of a TZif file
     *           from the time zone database. If present, this will be used instead of
     *           loading anything from the environment. You are then responsible for
     *           updating timezone_data when the definition changes.
     *           Calendar spec matching is based on literal matching of the clock time
     *           with no special handling of DST: if you write a calendar spec that fires
     *           at 2:30am and specify a time zone that follows DST, that action will not
     *           be triggered on the day that has no 2:30am. Similarly, an action that
     *           fires at 1:30am will be triggered twice on the day that has two 1:30s.
     *     @type string $timezone_data
     * }
     */
    public function __construct($data = NULL) {
        \GPBMetadata\Temporal\Api\Schedule\V1\Message::initOnce();
        parent::__construct($data);
    }

    /**
     * Calendar-based specifications of times.
     *
     * Generated from protobuf field <code>repeated .temporal.api.schedule.v1.CalendarSpec calendar = 1;</code>
     * @return \Google\Protobuf\Internal\RepeatedField
     */
    public function getCalendar()
    {
        return $this->calendar;
    }

    /**
     * Calendar-based specifications of times.
     *
     * Generated from protobuf field <code>repeated .temporal.api.schedule.v1.CalendarSpec calendar = 1;</code>
     * @param \Temporal\Api\Schedule\V1\CalendarSpec[]|\Google\Protobuf\Internal\RepeatedField $var
     * @return $this
     */
    public function setCalendar($var)
    {
        $arr = GPBUtil::checkRepeatedField($var, \Google\Protobuf\Internal\GPBType::MESSAGE, \Temporal\Api\Schedule\V1\CalendarSpec::class);
        $this->calendar = $arr;

        return $this;
    }

    /**
     * Interval-based specifications of times.
     *
     * Generated from protobuf field <code>repeated .temporal.api.schedule.v1.IntervalSpec interval = 2;</code>
     * @return \Google\Protobuf\Internal\RepeatedField
     */
    public function getInterval()
    {
        return $this->interval;
    }

    /**
     * Interval-based specifications of times.
     *
     * Generated from protobuf field <code>repeated .temporal.api.schedule.v1.IntervalSpec interval = 2;</code>
     * @param \Temporal\Api\Schedule\V1\IntervalSpec[]|\Google\Protobuf\Internal\RepeatedField $var
     * @return $this
     */
    public function setInterval($var)
    {
        $arr = GPBUtil::checkRepeatedField($var, \Google\Protobuf\Internal\GPBType::MESSAGE, \Temporal\Api\Schedule\V1\IntervalSpec::class);
        $this->interval = $arr;

        return $this;
    }

    /**
     * Any timestamps matching any of the exclude_calendar specs will be
     * skipped.
     *
     * Generated from protobuf field <code>repeated .temporal.api.schedule.v1.CalendarSpec exclude_calendar = 3;</code>
     * @return \Google\Protobuf\Internal\RepeatedField
     */
    public function getExcludeCalendar()
    {
        return $this->exclude_calendar;
    }

    /**
     * Any timestamps matching any of the exclude_calendar specs will be
     * skipped.
     *
     * Generated from protobuf field <code>repeated .temporal.api.schedule.v1.CalendarSpec exclude_calendar = 3;</code>
     * @param \Temporal\Api\Schedule\V1\CalendarSpec[]|\Google\Protobuf\Internal\RepeatedField $var
     * @return $this
     */
    public function setExcludeCalendar($var)
    {
        $arr = GPBUtil::checkRepeatedField($var, \Google\Protobuf\Internal\GPBType::MESSAGE, \Temporal\Api\Schedule\V1\CalendarSpec::class);
        $this->exclude_calendar = $arr;

        return $this;
    }

    /**
     * Any timestamps before start_time will be skipped. Together, start_time
     * and end_time make an inclusive interval.
     *
     * Generated from protobuf field <code>.google.protobuf.Timestamp start_time = 4 [(.gogoproto.stdtime) = true];</code>
     * @return \Google\Protobuf\Timestamp
     */
    public function getStartTime()
    {
        return $this->start_time;
    }

    /**
     * Any timestamps before start_time will be skipped. Together, start_time
     * and end_time make an inclusive interval.
     *
     * Generated from protobuf field <code>.google.protobuf.Timestamp start_time = 4 [(.gogoproto.stdtime) = true];</code>
     * @param \Google\Protobuf\Timestamp $var
     * @return $this
     */
    public function setStartTime($var)
    {
        GPBUtil::checkMessage($var, \Google\Protobuf\Timestamp::class);
        $this->start_time = $var;

        return $this;
    }

    /**
     * Any timestamps after end_time will be skipped.
     *
     * Generated from protobuf field <code>.google.protobuf.Timestamp end_time = 5 [(.gogoproto.stdtime) = true];</code>
     * @return \Google\Protobuf\Timestamp
     */
    public function getEndTime()
    {
        return $this->end_time;
    }

    /**
     * Any timestamps after end_time will be skipped.
     *
     * Generated from protobuf field <code>.google.protobuf.Timestamp end_time = 5 [(.gogoproto.stdtime) = true];</code>
     * @param \Google\Protobuf\Timestamp $var
     * @return $this
     */
    public function setEndTime($var)
    {
        GPBUtil::checkMessage($var, \Google\Protobuf\Timestamp::class);
        $this->end_time = $var;

        return $this;
    }

    /**
     * All timestamps will be incremented by a random value from 0 to this
     * amount of jitter. Default: 1 second
     *
     * Generated from protobuf field <code>.google.protobuf.Duration jitter = 6 [(.gogoproto.stdduration) = true];</code>
     * @return \Google\Protobuf\Duration
     */
    public function getJitter()
    {
        return $this->jitter;
    }

    /**
     * All timestamps will be incremented by a random value from 0 to this
     * amount of jitter. Default: 1 second
     *
     * Generated from protobuf field <code>.google.protobuf.Duration jitter = 6 [(.gogoproto.stdduration) = true];</code>
     * @param \Google\Protobuf\Duration $var
     * @return $this
     */
    public function setJitter($var)
    {
        GPBUtil::checkMessage($var, \Google\Protobuf\Duration::class);
        $this->jitter = $var;

        return $this;
    }

    /**
     * Time zone to interpret all CalendarSpecs in.
     * If unset, defaults to UTC. We recommend using UTC for your application if
     * at all possible, to avoid various surprising properties of time zones.
     * Time zones may be provided by name, corresponding to names in the IANA
     * time zone database (see https://www.iana.org/time-zones). The definition
     * will be loaded by the Temporal server from the environment it runs in.
     * If your application requires more control over the time zone definition
     * used, it may pass in a complete definition in the form of a TZif file
     * from the time zone database. If present, this will be used instead of
     * loading anything from the environment. You are then responsible for
     * updating timezone_data when the definition changes.
     * Calendar spec matching is based on literal matching of the clock time
     * with no special handling of DST: if you write a calendar spec that fires
     * at 2:30am and specify a time zone that follows DST, that action will not
     * be triggered on the day that has no 2:30am. Similarly, an action that
     * fires at 1:30am will be triggered twice on the day that has two 1:30s.
     *
     * Generated from protobuf field <code>string timezone_name = 10;</code>
     * @return string
     */
    public function getTimezoneName()
    {
        return $this->timezone_name;
    }

    /**
     * Time zone to interpret all CalendarSpecs in.
     * If unset, defaults to UTC. We recommend using UTC for your application if
     * at all possible, to avoid various surprising properties of time zones.
     * Time zones may be provided by name, corresponding to names in the IANA
     * time zone database (see https://www.iana.org/time-zones). The definition
     * will be loaded by the Temporal server from the environment it runs in.
     * If your application requires more control over the time zone definition
     * used, it may pass in a complete definition in the form of a TZif file
     * from the time zone database. If present, this will be used instead of
     * loading anything from the environment. You are then responsible for
     * updating timezone_data when the definition changes.
     * Calendar spec matching is based on literal matching of the clock time
     * with no special handling of DST: if you write a calendar spec that fires
     * at 2:30am and specify a time zone that follows DST, that action will not
     * be triggered on the day that has no 2:30am. Similarly, an action that
     * fires at 1:30am will be triggered twice on the day that has two 1:30s.
     *
     * Generated from protobuf field <code>string timezone_name = 10;</code>
     * @param string $var
     * @return $this
     */
    public function setTimezoneName($var)
    {
        GPBUtil::checkString($var, True);
        $this->timezone_name = $var;

        return $this;
    }

    /**
     * Generated from protobuf field <code>bytes timezone_data = 11;</code>
     * @return string
     */
    public function getTimezoneData()
    {
        return $this->timezone_data;
    }

    /**
     * Generated from protobuf field <code>bytes timezone_data = 11;</code>
     * @param string $var
     * @return $this
     */
    public function setTimezoneData($var)
    {
        GPBUtil::checkString($var, False);
        $this->timezone_data = $var;

        return $this;
    }

}

